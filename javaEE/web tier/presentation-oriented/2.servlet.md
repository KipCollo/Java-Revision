# Servlet

A `servlet` is a Java™ technology-based Web component, managed by a container, that generates dynamic content. Like other Java technology-based components, servlets are platform-independent Java classes that are compiled to platform-neutral byte code that can be loaded dynamically into and run by a Java technology-enabled Web server. Containers, sometimes called servlet engines, are Web server extensions that provide servlet functionality. Servlets interact with Web clients via a request/response paradigm implemented by the servlet container.

Initially, Common Gateway Interface (CGI) scripts were the main technology used to generate dynamic content. Although widely used, CGI scripting technology has a number of shortcomings, including platform dependence and lack of scalability. To address these limitations, Java Servlet technology was created as a portable way to provide dynamic, user-oriented content.

A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol.

A servlet is a Java class that runs in a Java-enabled server. An HTTP servlet is a special type of servlet that handles an HTTP request and provides an HTTP response, usually in the form of an HTML page. The most common use of WebLogic HTTP servlets is to create interactive applications using standard Web browsers for the client-side
presentation while WebLogic Server handles the business logic as a server-side process. WebLogic HTTP servlets can access databases, Enterprise JavaBeans,messaging APIs, HTTP sessions, and other facilities of WebLogic Server

A servlet is a Java programming language class that is used to extend the capabilities of servers that host applications accessed by means of a request-response programming model. Although servlets can respond to any type of request, they are commonly used to extend the applications hosted by web servers. For such applications, Java Servlet technology defines HTTP-specific servlet classes.

The `javax.servlet` and `javax.servlet.http` packages provide interfaces and classes for writing servlets. All servlets must implement the Servlet interface, which defines life-cycle methods. When implementing a generic service, you can use or extend the `GenericServlet` class provided with the Java Servlet API. The HttpServlet class provides methods, such as doGet and doPost, for handling HTTP-specific services.

## Servlet Container

The servlet container is a part of a Web server or application server that provides the network services over which requests and responses are sent, decodes MIME-based
requests, and formats MIME-based responses. A servlet container also contains and manages servlets through their lifecycle.

A servlet container can be built into a host Web server, or installed as an add-on component to a Web Server via that server’s native extension API. Servlet containers
can also be built into or possibly installed into Web-enabled application servers.

All servlet containers must support HTTP as a protocol for requests and responses, but additional request/response-based protocols such as HTTPS (HTTP over SSL)
may be supported. The required versions of the HTTP specification that a container must implement are HTTP/1.1 and HTTP/2. When supporting HTTP/2, servlet containers must support the “h2” and “h2c” protocol identifiers. This implies all servlet containers must support ALPN. Because the container may have a caching mechanism described in RFC 7234 (HTTP/1.1 Caching), it may modify requests from the clients before delivering them to the servlet, may modify responses produced by servlets before sending them to the clients, or may respond to requests without delivering them to the servlet under the compliance with RFC 7234.

A servlet container may place security restrictions on the environment in which a servlet executes. In a Java Platform, Standard Edition (J2SE, v.1.3 or above) or Java
Platform, Enterprise Edition (Java EE, v.1.3 or above) environment, these restrictions should be placed using the permission architecture defined by the Java platform. For
example some application servers may limit the creation of a Thread object to insure that other components of the container are not negatively impacted.

Java SE 8 is the minimum version of the underlying Java platform with which servlet containers must be built.

The following is a typical sequence of events:-

1. A client (e.g., a Web browser) accesses a Web server and makes an HTTP request.
2. The request is received by the Web server and handed off to the servlet container.The servlet container can be running in the same process as the host Web server,
in a different process on the same host, or on a different host from the Web server for which it processes requests.
3. The servlet container determines which servlet to invoke based on the configuration of its servlets, and calls it with objects representing the request and response.
4. The servlet uses the request object to find out who the remote user is, what HTTP POST parameters may have been sent as part of this request, and other relevant data. The servlet performs whatever logic it was programmed with, and generates data to send back to the client. It sends this data back to the client via the response object.
5. Once the servlet has finished processing the request, the servlet container ensures that the response is properly flushed, and returns control back to the host Web server.

Comparing Servlets with Other Technologies:- In functionality, servlets provide a higher level abstraction than Common Gateway Interface (CGI) programs but a lower level of abstraction than that provided by web frameworks such as JavaServer Faces.
Servlets have the following advantages over other server extension mechanisms:

1. They are generally much faster than CGI scripts because a different process model is used.
2. They use a standard API that is supported by many Web servers.
3. They have all the advantages of the Java programming language, including ease of development and platform independence.
4. They can access the large set of APIs available for the Java platform.

## Servlet Life Cycle

The life cycle of a servlet is controlled by the container in which the servlet has been deployed. When a request is mapped to a servlet, the container performs the following steps.
1. If an instance of the servlet does not exist, the web container
    a. Loads the servlet class.
    b. Creates an instance of the servlet class.
    c. Initializes the servlet instance by calling the init method.
2. Invokes the service method, passing request and response objects.

If the container needs to remove the servlet, it finalizes the servlet by calling the servlet’s destroy method.

You can monitor and react to events in a servlet’s life cycle by defining listener objects whose methods get invoked when life-cycle events occur. To use these listener objects you must define and specify the listener class.

## The Servlet Interface

The Servlet interface is the central abstraction of the Java Servlet API. All servlets implement this interface either directly, or more commonly, by extending a class that
implements the interface. The two classes in the Java Servlet API that implement the Servlet interface are GenericServlet and HttpServlet. For most purposes, Developers will extend HttpServlet to implement their servlets.

Request Handling Methods:- The basic Servlet interface defines a service method for handling client requests.This method is called for each request that the servlet container routes to an instance of a servlet.
The handling of concurrent requests to a Web application generally requires that the Web Developer design servlets that can deal with multiple threads executing within
the service method at a particular time.Generally the Web container handles concurrent requests to the same servlet by concurrent execution of the service method on different threads.

HTTP Specific Request Handling Methods:- The HttpServlet abstract subclass adds additional methods beyond the basic Servlet interface that are automatically called by the service method in the HttpServlet class to aid in processing HTTP-based requests. These methods are:
• doGet for handling HTTP GET requests
• doPost for handling HTTP POST requests
• doPut for handling HTTP PUT requests
• doDelete for handling HTTP DELETE requests
• doHead for handling HTTP HEAD requests
• doOptions for handling HTTP OPTIONS requests
• doTrace for handling HTTP TRACE requests
Typically when developing HTTP-based servlets, a Servlet Developer will only concern himself with the doGet and doPost methods. The other methods are considered to be methods for use by programmers very familiar with HTTP programming.

Number of Instances:- The servlet declaration which is either via the annotation-“Annotations and pluggability” or part of the deployment descriptor of the Web
application containing the servlet “Deployment Descriptor”, controls how the servlet container provides instances of the servlet.
For a servlet not hosted in a distributed environment (the default), the servlet container must use only one instance per servlet declaration. However, for a servlet
implementing the SingleThreadModel interface, the servlet container may instantiate multiple instances to handle a heavy request load and serialize requests to a particular instance.
In the case where a servlet was deployed as part of an application marked in the deployment descriptor as distributable, a container may have only one instance per
servlet declaration per Java Virtual Machine (JVM™)1. However, if the servlet in a distributable application implements the SingleThreadModel interface, the container
may instantiate multiple instances of that servlet in each JVM of the container.

The use of the SingleThreadModel interface guarantees that only one thread at a time will execute in a given servlet instance’s service method. It is important to
note that this guarantee only applies to each servlet instance, since the container may choose to pool such objects. Objects that are accessible to more than one servlet
instance at a time, such as instances of HttpSession, may be available at any particular time to multiple servlets, including those that implement SingleThreadModel.
It is recommended that a developer take other means to resolve those issues instead of implementing this interface, such as avoiding the usage of an instance variable or
synchronizing the block of the code accessing those resources. The SingleThreadModel Interface is deprecated in this version of the specification.

- Servlet Life Cycle:- A servlet is managed through a well defined life cycle that defines how it is loaded and instantiated, is initialized, handles requests from clients, and is taken out of service. This life cycle is expressed in the API by the init, service, and destroy methods of the javax.servlet.Servlet interface that all servlets must implement directly or indirectly through the GenericServlet or HttpServlet abstract classes.


## Jakarta Servlet

Jakarta Servlet is a corner stone web framework that can act as a presentation-oriented as well as a service-oriented web application. Jakarta Servlet intends to reduce the boilerplate code needed to convert the HTTP request into a Java object and to offer a Java object as an HTTP response, and to manage all the lifecycle around them.

To implement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that extends javax.servlet.http.HttpServlet.

This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server. These are known as life-cycle methods and are called in the following sequence:

1. The servlet is constructed, then initialized with the init method.
2. Any calls from clients to the service method are handled.
3. The servlet is taken out of service, then destroyed with the destroy method, then garbage collected and finalized.

A servlet is a Java programming language class that directly or indirectly implements the jakarta.servlet.Servlet interface. The jakarta.servlet and jakarta.servlet.http packages provide interfaces and classes for writing servlets. All servlets must implement the jakarta.servlet.Servlet interface, which defines lifecycle methods such as init, service, and destroy.A servlet is a java class that extends HttpServlet class and runs on server within a servlet container.


`Creating a servlet`:-

In a typical Jakarta Servlet based web application, the class must extend jakarta.servlet.http.HttpServlet and override one of the doXxx methods where Xxx represents the HTTP method of interest.

```java
public class StudentServleet extends HttpServlet{

}
```

* HttpServlet -Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site. A subclass of HttpServlet must override at least one method, usually one of these:

 1. doGet, if the servlet supports HTTP GET requests
 2. doPost, for HTTP POST requests
 3. doPut, for HTTP PUT requests
 4. doDelete, for HTTP DELETE requests
 5. init and destroy, to manage resources that are held for the life of the servlet
 6. getServletInfo, which the servlet uses to provide information about itself

There's almost no reason to override the service method. service handles standard HTTP requests by dispatching them to the handler methods for each HTTP request type (the doXXX methods listed above).
Servlets typically run on multithreaded servers, so be aware that a servlet must handle concurrent requests and be careful to synchronize access to shared resources. Shared resources include in-memory data such as instance or class variables and external objects such as files, database connections, and network connections.

```java
public class StudentServleet extends HttpServlet{

    @Override
    public void doPost(HttpRequesst request, HttpResponse response)throws ServletException,IOException
    {
        ...
    }
}
```

`Creating Service Method`:-

The service provided by a servlet is implemented in the service method of a GenericServlet, in the doMethod methods (where Method can take the value Get, Delete, Options, Post, Put, or Trace) of an HttpServlet object, or in any other protocol-specific methods defined by a class that implements the Servlet interface. The term service method is used for any method in a servlet class that provides a service to a client.

The general pattern for a service method is to extract information from the request, access external resources, and then populate the response, based on that information. For HTTP servlets, the correct procedure for populating the response is to do the following:

1. Retrieve an output stream from the response.
2. Fill in the response headers.
3. Write any body content to the output stream.

Response headers must always be set before the response has been committed. The web container will ignore any attempt to set or add headers after the response has been committed.
Getting Information from Requests

A request contains data passed between a client and the servlet. All requests implement the ServletRequest interface. This interface defines methods for accessing the following information:

    Parameters, which are typically used to convey information between clients and servlets

    Object-valued attributes, which are typically used to pass information between the web container and a servlet or between collaborating servlets

    Information about the protocol used to communicate the request and about the client and server involved in the request

    Information relevant to localization

You can also retrieve an input stream from the request and manually parse the data. To read character data, use the BufferedReader object returned by the request’s getReader method. To read binary data, use the ServletInputStream returned by getInputStream.

HTTP servlets are passed an HTTP request object, HttpServletRequest, which contains the request URL, HTTP headers, query string, and so on. An HTTP request URL contains the following parts:

http://[host]:[port][request-path]?[query-string]

The request path is further composed of the following elements:

    Context path: A concatenation of a forward slash (/) with the context root of the servlet’s web application.

    Servlet path: The path section that corresponds to the component alias that activated this request. This path starts with a forward slash (/).

    Path info: The part of the request path that is not part of the context path or the servlet path.

You can use the getContextPath, getServletPath, and getPathInfo methods of the HttpServletRequest interface to access this information. Except for URL encoding differences between the request URI and the path parts, the request URI is always comprised of the context path plus the servlet path plus the path info.

Query strings are composed of a set of parameters and values. Individual parameters are retrieved from a request by using the getParameter method. There are two ways to generate query strings.

    A query string can explicitly appear in a web page.

    A query string is appended to a URL when a form with a GET HTTP method is submitted.

Constructing Responses

A response contains data passed between a server and the client. All responses implement the ServletResponse interface. This interface defines methods that allow you to

    Retrieve an output stream to use to send data to the client. To send character data, use the PrintWriter returned by the response’s getWriter method. To send binary data in a Multipurpose Internet Mail Extensions (MIME) body response, use the ServletOutputStream returned by getOutputStream. To mix binary and text data, as in a multipart response, use a ServletOutputStream and manage the character sections manually.

    Indicate the content type (for example, text/html) being returned by the response with the setContentType(String) method. This method must be called before the response is committed. A registry of content type names is kept by the Internet Assigned Numbers Authority (IANA) at http://www.iana.org/assignments/media-types/.

    Indicate whether to buffer output with the setBufferSize(int) method. By default, any content written to the output stream is immediately sent to the client. Buffering allows content to be written before anything is sent back to the client, thus providing the servlet with more time to set appropriate status codes and headers or forward to another web resource. The method must be called before any content is written or before the response is committed.

    Set localization information, such as locale and character encoding. See Chapter 17, Internationalizing and Localizing Web Applications for details.

HTTP response objects, javax.servlet.http.HttpServletResponse, have fields representing HTTP headers, such as the following:

    Status codes, which are used to indicate the reason a request is not satisfied or that a request has been redirected.

    Cookies, which are used to store application-specific information at the client. Sometimes, cookies are used to maintain an identifier for tracking a user’s session (see Session Tracking).

## Configuring and Mapping Servlets

Before you can request a servlet, you must use the web.xml file to map the servlet to a URL.
You define servlets as a part of a Web application in several entries in the J2EE standard Web Application deployment descriptor, web.xml. The web.xml file is located in the WEB-INF directory of your Web application.

The first line should be an XML declaration that indicates the version of XML and the character of the document.Then, the web-app element specifies the version of Java EE specification being used.These elements are same from one web application to another, and they are usually generated by your IDE.

After web-app element, the servlet element declares the servlet.Here,the servlet-name element specifies an internal name that's used to uniquely identify the servlet within web.xml file.then, the the servlet-class element specifies the package and name of the class for the servlet.

After servlet element, the servlet-mapping element maps the servlet to a URL.Here,the servlet-name element identifies the servlet by specifying the name that's used in servlet element.Then, the url-pattern element maps the servlet to the URL in root directory.

Finally, this web.xml sets a couple of other configuration settings for the application.First, session-config element sets the session timeout.As a result, any resources that are associated with a user will be released if the user hasn't ccessed the session within classidied time.Seond, there is welcome-file-list which when a user requests the root directory of the application,The HTML page will be displayed.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="6.0" xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee
                             https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd">

    <!-- Servlet Mapping -->
    <servlet>
        <servlet-name>name</servlet-name>
        <servlet-class>com.kipcollo.ExampleServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>name</servlet-name>
        <url-pattern>/home</url-pattern>
    </servlet-mapping>

    <!-- Session Configuration -->
    <session-config>
        <!-- Session timeout in minutes -->
        <session-timeout>30</session-timeout>

    <!-- Optional: Cookie-based session tracking -->
    <cookie-config>
        <name>JSESSIONID</name>
        <http-only>true</http-only>
        <secure>true</secure> <!-- Set to true if using HTTPS -->
        <max-age>-1</max-age> <!-- Session cookie (expires when browser closes) -->
    </cookie-config>

        <!-- Optional: Tracking mode (COOKIE, URL, SSL) -->
        <tracking-mode>COOKIE</tracking-mode>
    </session-config>

    <!-- Welcome file -->
    <welcome-file-list>
        <welcome-file>index.html</welcome-file>
        <welcome-file>index.jsp</welcome-file>
    </welcome-file-list>

     <!-- Character Encoding Filter (optional but recommended) -->
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>

    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- Context parameters (optional) -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring-config.xml</param-value>
    </context-param>

</web-app>
```

## The Request

The request object encapsulates all information from the client request. In the HTTP protocol, this information is transmitted from the client to the server in the HTTP
headers and the message body of the request.

* ServletRequest- Defines an object to provide client request information to a servlet. The servlet container creates a ServletRequest object and passes it as an argument to the servlet's service method.A ServletRequest object provides data including parameter name and values, attributes, and an input stream. Interfaces that extend ServletRequest can provide additional protocol-specific data (for example, HTTP data is provided by HttpServletRequest.)

1. String getParameter(String name) -Returns the value of a request parameter as a String, or null if the parameter does not exist.
2. void setAttribute(String name, Object o)- Stores an attribute in this request
3. Object getAttribute(String name)- Returns the value of the named attribute as an Object, or null if no attribute of the given name exists.

* HttpServletRequest-Extends the ServletRequest interface to provide request information for HTTP servlets.The servlet container creates an HttpServletRequest object and passes it as an argument to the servlet's service methods (doGet, doPost, etc)

1. Cookie[] getCookies()- Returns an array containing all of the Cookie objects the client sent with this request.
2. HttpSession getSession()-Returns the current session associated with this request, or if the request does not have a session, creates one.
3. HttpSession getSession(boolean create)-Returns the current HttpSession associated with this request or, if there is no current session and create is true, returns a new session.


**HTTP Protocol Parameters**:- Request parameters for the servlet are the strings sent by the client to a servlet container as part of its request. When the request is an HttpServletRequest object,and conditions set out in ”When Parameters Are Available” are met, the container populates the parameters from the URI query string and POST-ed data.

The parameters are stored as a set of name-value pairs. Multiple parameter values can exist for any given parameter name. The following methods of the ServletRequest interface are available to access parameters:

1. `getParameter(String param)` - Returns value of the specified parameter as a string if it exists or null if it doesn't.Often,this value is defined in Value attribute of the control in HTML pages or JSP.For textbox,that's usually value entered by user.For a group of radio radio buttons or a combo box,that's value of the button or item selected by user.
2. The `getParameterValues(String param)` method returns an array of String objects containing all the parameter values associated with a parameter name. The value returned from
the getParameter method must be the first value in the array of String objects returned by getParameterValues.useful for controls like controls like list boxes that allow multiple selections.After returning array of the String Objects,you can use a loop to get values.
3. The `getParameterMap` method returns a java.util.Map of the parameter of the request, which contains names as keys and parameter values as map values.Data from the query string and the post body are aggregated into the request parameter set. Query string data is presented before post body data. For example, if a request is made with a query string of a=hello and a post body of a=goodbye&a=world, the resulting parameter set would be ordered a=(hello, goodbye, world).Path parameters that are part of a GET request (as defined by HTTP 1.1) are not exposed by these APIs. They must be parsed from the String values returned by the getRequestURI method or the getPathInfo method.
4. getParameterValues
5. getParameterMap
6. `getPrameterNames()`:- Returns an Enumeration object that contains names of all parameters contained in request.If request has no parameters,the method returns an empty Enumeration object.You can search through Enumeration object to get parameter names,and you can use the getParameter method to return value of each parameter name.Enumeration object is a collection that can be searched element by element.To determine if more element exist in the collection,you can use hasMoreElements method,which returns a Boolean value.And to get next element in the collection,you can use nextElement method.

The following are the conditions that must be met before post form data will be populated to the parameter set:

1. The request is an HTTP or HTTPS request.
2. The HTTP method is POST.
3. The content type is application/x-www-form-urlencoded.
4. The servlet has made an initial call of any of the getParameter family of methods on the request object.
If the conditions are not met and the post form data is not included in the parameter
set, the post data must still be available to the servlet via the request object’s input
stream. If the conditions are met, post form data will no longer be available for
reading directly from the request object’s input stream.

File upload
Servlet container allows files to be uploaded when data is sent as multipart/form-
data.
The servlet container provides multipart/form-data processing if any one of the
following conditions is met.
■The servlet handling the request is annotated with the @MultipartConfig as
defined in Section 8.1.5, “@MultipartConfig” on page 8-74.
■Deployment descriptors contain a multipart-config element for the servlet
handling the request.
How data in a request of type multipart/form-data is made available depends on
whether the servlet container provides multipart/form-data processing:
■
If the servlet container provides multipart/form-data processing, the data is
made available through the following methods in HttpServletRequest:
■public Collection<Part> getParts()
■public Part getPart(String name)
Each part provides access to the headers, content type related with it and the
content via the Part.getInputStream method.
For parts with form-data as the Content-Disposition, but without a filename,
the string value of the part will also be available through the getParameter and
getParameterValues methods on HttpServletRequest, using the name of the
part.
■
3.3
If the servlet container does not provide the multi-part/form-data processing,
the data will be available through the HttpServletReuqest.getInputStream.

- **Attributes**:- Attributes are objects associated with a request. Attributes may be set by the container to express information that otherwise could not be expressed via the API,or may be set by a servlet to communicate information to another servlet (via the RequestDispatcher). Attributes are accessed with the following methods of the
ServletRequest interface:

1. `getAttribute(String name)` Returns the value of specified attribute as an Object type.If no attribute exists for specified name,this method returns a null value.
2. getAttributeNames
3. `setAttribute(String name,Object o)` Stores any objject in the request as an attribute and specifies a name of the attribute.Attributes are reset between requests.

Only one attribute value may be associated with an attribute name.Attribute names beginning with the prefixes of java. and javax. are reserved for definition by this specification. Similarly, attribute names beginning with the prefixes of sun., com.sun., oracle and com.oracle are reserved for definition by Oracle Corporation. It is suggested that all attributes placed in the attribute set be named in accordance with the reverse domain name convention suggested by the Java Programming Language Specification1 for package naming.

When you use MVC pattern, your servlets often need to forward a request object to a JSP or another servlet.First you need to store any object in request object, you use the `setAttribute` method.Once you store an object in request object,you can use the `getAttribute` method to retrieve the object.The request attributes are reset between requests.As a result if you store an Object as request attribute and forward that request to a JSP,that object will only be available to that JSP and won't be available in later sessions.

These methods are often used in conjuction with a RequestDispatcher object that's used to forward a request.

- Headers:- A servlet can access the headers of an HTTP request through the following methods of the HttpServletRequest interface:

1. getHeader
2. getHeaders
3. getHeaderNames
The getHeader method returns a header given the name of the header. There can be
multiple headers with the same name, e.g. Cache-Control headers, in an HTTP
request. If there are multiple headers with the same name, the getHeader method
returns the first header in the request. The getHeaders method allows access to all
the header values associated with a particular header name, returning an
Enumeration of String objects.
Headers may contain String representations of int or Date data. The following
convenience methods of the HttpServletRequest interface provide access to header
data in a one of these formats:

1. getIntHeader
2. getDateHeader

If the getIntHeader method cannot translate the header value to an int, a
NumberFormatException is thrown. If the getDateHeader method cannot translate
the header to a Date object, an IllegalArgumentException is thrown.

Request Path Elements
The request path that leads to a servlet servicing a request is composed of many
important sections. The following elements are obtained from the request URI path
and exposed via the request object:
■
■
■
Context Path: The path prefix associated with the ServletContext that this
servlet is a part of. If this context is the “default” context rooted at the base of the
Web server’s URL name space, this path will be an empty string. Otherwise, if the
context is not rooted at the root of the server’s name space, the path starts with a
/ character but does not end with a / character.
Servlet Path: The path section that directly corresponds to the mapping which
activated this request. This path starts with a ’/’ character except in the case
where the request is matched with the ‘/*’ or ““ pattern, in which case it is an
empty string.
PathInfo: The part of the request path that is not part of the Context Path or the
Servlet Path. It is either null if there is no extra path, or is a string with a leading
‘/’.
The following methods exist in the HttpServletRequest interface to access this
information:
■
■
■
getContextPath
getServletPath
getPathInfo
It is important to note that, except for URL encoding differences between the request
URI and the path parts, the following equation is always true:
requestURI = contextPath + servletPath + pathInfo

Cookies
The HttpServletRequest interface provides the getCookies method to obtain an
array of cookies that are present in the request. These cookies are data sent from the
client to the server on every request that the client makes. Typically, the only
information that the client sends back as part of a cookie is the cookie name and the
cookie value. Other cookie attributes that can be set when the cookie is sent to the
browser, such as comments, are not typically returned. The specification also allows
for the cookies to be HttpOnly cookies. HttpOnly cookies indicate to the client that
they should not be exposed to client-side scripting code (It’s not filtered out unless
the client knows to look for this attribute). The use of HttpOnly cookies helps
mitigate certain kinds of cross-site scripting attacks.

Internationalization
Clients may optionally indicate to a Web server what language they would prefer
the response be given in. This information can be communicated from the client
using the Accept-Language header along with other mechanisms described in the
HTTP/1.1 specification. The following methods are provided in the ServletRequest
interface to determine the preferred locale of the sender:
■
■
getLocale
getLocales
The getLocale method will return the preferred locale for which the client wants to
accept content. See section 14.4 of RFC 7231 (HTTP/1.1) for more information about
how the Accept-Language header must be interpreted to determine the preferred
language of the client.
The getLocales method will return an Enumeration of Locale objects indicating, in
decreasing order starting with the preferred locale, the locales that are acceptable to
the client.
If no preferred locale is specified by the client, the locale returned by the getLocale
method must be the default locale for the servlet container and the getLocales
method must contain an enumeration of a single Locale element of the default
locale.

## Servlet Context

The ServletContext interface defines a servlet’s view of the Web application within
which the servlet is running. The Container Provider is responsible for providing an
implementation of the ServletContext interface in the servlet container. Using the
ServletContext object, a servlet can log events, obtain URL references to resources,
and set and store attributes that other servlets in the context can access.
A ServletContext is rooted at a known path within a Web server. For example, a
servlet context could be located at http://example.com/catalog. All requests that
begin with the /catalog request path, known as the context path, are routed to the
Web application associated with the ServletContext.

Initialization Parameters
The following methods of the ServletContext interface allow the servlet access to
context initialization parameters associated with a Web application as specified by
the Application Developer in the deployment descriptor:
■
■
getInitParameter
getInitParameterNames
Initialization parameters are used by an Application Developer to convey setup
information. Typical examples are a Webmaster’s e-mail address, or the name of a
system that holds critical data.

Configuration methods
The following methods are added to ServletContext since Servlet 3.0 to enable
programmatic definition of servlets, filters and the url pattern that they map to.
These methods can only be called during the initialization of the application either
from the contexInitialized method of a ServletContextListener
implementation or from the onStartup method of a
ServletContainerInitializer implementation. In addition to adding Servlets
and Filters, one can also look up an instance of a Registration object
corresponding to a Servlet or Filter or a map of all the Registration objects for the
Servlets or Filters. If the ServletContext passed to the ServletContextListener’s
contextInitialized method where the ServletContextListener was neither
declared in web.xml or web-fragment.xml nor annotated with @WebListener
then an UnsupportedOperationException MUST be thrown for all the methods
defined in ServletContext for programmatic configuration of servlets, filters and
listeners.

Context Attributes
A servlet can bind an object attribute into the context by name. Any attribute bound
into a context is available to any other servlet that is part of the same Web
application. The following methods of ServletContext interface allow access to this
functionality:
■setAttribute
■■getAttribute
getAttributeNames
■removeAttribute

## The Response

The response object encapsulates all information to be returned from the server to the client. In the HTTP protocol, this information is transmitted from the server to
the client either by HTTP headers or the message body of the request.


* ServletResponse-Defines an object to assist a servlet in sending a response to the client. The servlet container creates a ServletResponse object and passes it as an argument to the servlet's service method.

1. PrintWriter getWriter()-Returns a PrintWriter object that can send character text to the client.
2. void setContentType(String type)-Sets the content type of the response being sent to the client, if the response has not been committed yet.

Before you can create a PrintWriter object,you must set the content type.This allows the getWriter method to return a PrintWriter object that uses the proper content type.

* HttpServletResponse-Extends the ServletResponse interface to provide HTTP-specific functionality in sending a response. For example, it has methods to access HTTP headers and cookies.The servlet container creates an HttpServletResponse object and passes it as an argument to the servlet's service methods (doGet, doPost, etc)

1. void addCookie(Cookie cookie)-Adds the specified cookie to the response.
2. int getStatus()-Gets the current status code of this response.
3. void sendRedirect(String location)- Sends a temporary redirect response to the client using the specified redirect location URL and clears the buffer.

### Forwading and Redirecting Requests

* Forwading Request and Response-
* Redirect Response-To redirect response you use redirect method of response object.Typically used when you transfer control to URL outside your application.

```java
//How to forward the request to an HTML page
String url = "/display_email_entry.html";
RequestDispatcher dispatcher =getServletContext().getRequestDispatcher(url);
dispatcher.forward(request, response);

//How to forward the request to a JSP
String url = "/display_email_entry.jsp";
RequestDispatcher dispatcher =getServletContext().getRequestDispatcher(url);
dispatcher.forward(request, response);

// How to forward the request to a servlet
String url = "/cart/displayInvoice";
RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(url);
dispatcher.forward(request, response);
```

```java
// How to redirect a response relative to the current directory
response.sendRedirect("join_email_list.html");

// How to redirect a response relative to the servlet engine
response.sendRedirect("/musicStore/email/join_email_list.jsp");

// How to redirect a response to a different web server
response.sendRedirect("http://www.murach.com/email/");
```

- Buffering:- A servlet container is allowed, but not required, to buffer output going to the client for efficiency purposes. Typically servers that do buffering make it the default, but allow servlets to specify buffering parameters.
The following methods in the ServletResponse interface allow a servlet to access and set buffering information:

1. getBufferSize
2. setBufferSize
3. isCommitted
4. reset
5. resetBuffer
6. flushBuffer

These methods are provided on the ServletResponse interface to allow buffering operations to be performed whether the servlet is using a ServletOutputStream or a Writer.
The getBufferSize method returns the size of the underlying buffer being used. If no buffering is being used, this method must return the int value of 0 (zero).
The servlet can request a preferred buffer size by using the setBufferSize method.
The buffer assigned is not required to be the size requested by the servlet, but must
be at least as large as the size requested. This allows the container to reuse a set of
fixed size buffers, providing a larger buffer than requested if appropriate. The method must be called before any content is written using a ServletOutputStream
or Writer. If any content has been written or the response object has been
committed, this method must throw an IllegalStateException.
The isCommitted method returns a boolean value indicating whether any response
bytes have been returned to the client. The flushBuffer method forces content in
the buffer to be written to the client.
The reset method clears data in the buffer when the response is not committed.
Headers, status codes and the state of calling getWriter or getOutputStream set
by the servlet prior to the reset call must be cleared as well. The resetBuffer
method clears content in the buffer if the response is not committed without clearing
the headers and status code.
If the response is committed and the reset or resetBuffer method is called, an
IllegalStateException must be thrown. The response and its associated buffer will
be unchanged.
When using a buffer, the container must immediately flush the contents of a filled
buffer to the client. If this is the first data that is sent to the client, the response is
considered to be committed.

- Headers:- A servlet can set headers of an HTTP response via the following methods of the HttpServletResponse interface:

1. setHeader - The setHeader method sets a header with a given name and value. A previous header is replaced by the new header. Where a set of header values exist for the name, the values are cleared and replaced with the new value.
2. addHeader - The addHeader method adds a header value to the set with a given name. If there are no headers already associated with the name, a new set is created.

Headers may contain data that represents an int or a Date object. The following convenience methods of the HttpServletResponse interface allow a servlet to set a
header using the correct formatting for the appropriate data type:

1. setIntHeader
2. setDateHeader
3. addIntHeader
4. addDateHeader

- **Convenience Methods**:- The following convenience methods exist in the HttpServletResponse interface:

1. `sendRedirect` -The sendRedirect method will set the appropriate headers and content body to redirect the client to a different URL. It is legal to call this method with a relative URL path, however the underlying container must translate the relative path to a fully qualified URL for transmission back to the client. If a partial URL is given and, for whatever reason, cannot be converted into a valid URL, then this method must throw an IllegalArgumentException.
2. `sendError` - The sendError method will set the appropriate headers and content body for an error message to return to the client. An optional String argument can be provided to the sendError method which can be used in the content body of the error.

These methods will have the side effect of committing the response, if it has not already been committed, and terminating it. No further output to the client should
be made by the servlet after these methods are called. If data is written to the response after these methods are called, the data is ignored.
If data has been written to the response buffer, but not returned to the client (i.e. the response is not committed), the data in the response buffer must be cleared and
replaced with the data set by these methods. If the response is committed, these methods must throw an IllegalStateException.

## Sessions

The Hypertext Transfer Protocol (HTTP) is by design a stateless protocol. To build
effective Web applications, it is imperative that requests from a particular client be
associated with each other. Many strategies for session tracking have evolved over
time, but all are difficult or troublesome for the programmer to use directly.
This specification defines a simple HttpSession interface that allows a servlet
container to use any of several approaches to track a user’s session without
involving the Application Developer in the nuances of any one approach.

Session Tracking Mechanisms
The following sections describe approaches to tracking a user’s sessions
Cookies
Session tracking through HTTP cookies is the most used session tracking mechanism
and is required to be supported by all servlet containers.
The container sends a cookie to the client. The client will then return the cookie on
each subsequent request to the server, unambiguously associating the request with a
session. The standard name of the session tracking cookie must be JSESSIONID.
Containers may allow the name of the session tracking cookie to be customized
through container specific configuration.
All servlet containers MUST provide an ability to configure whether or not the
container marks the session tracking cookie as HttpOnly. The established
configuration must apply to all contexts for which a context specific configuration
has not been established (see SessionCookieConfig javadoc for more details).
If a web application configures a custom name for its session tracking cookies, the
same custom name will also be used as the name of the URI parameter if the session
id is encoded in the URL (provided that URL rewriting has been enabled).

SSL Sessions
Secure Sockets Layer, the encryption technology used in the HTTPS protocol, has a
built-in mechanism allowing multiple requests from a client to be unambiguously
identified as being part of a session. A servlet container can easily use this data to
define a session.

URL Rewriting
URL rewriting is the lowest common denominator of session tracking. When a client
will not accept a cookie, URL rewriting may be used by the server as the basis for
session tracking. URL rewriting involves adding data, a session ID, to the URL path
that is interpreted by the container to associate the request with a session.
The session ID must be encoded as a path parameter in the URL string. The name of
the parameter must be jsessionid. Here is an example of a URL containing encoded
path information:
http://www.example.com/catalog/index.html;jsessionid=1234
URL rewriting exposes session identifiers in logs, bookmarks, referer headers, cached HTML,
and the URL bar. URL rewriting should not be used as a session tracking mechanism where
cookies or SSL sessions are supported and suitable.

Session Integrity
Web containers must be able to support the HTTP session while servicing HTTP
requests from clients that do not support the use of cookies. To fulfill this
requirement, Web containers commonly support the URL rewriting mechanism.

## Annotations and pluggability

In a web application, classes using annotations will have their annotations processed only if they are located in the WEB-INF/classes directory, or if they are packaged
in a jar file located in WEB-INF/lib within the application.

The web application deployment descriptor contains a “metadata-complete” attribute on the web-app element. This attribute defines whether this deployment descriptor and any web fragments, if any, are complete, or whether the class files available to this module and packaged with this application should be examined for annotations that specify deployment information. Deployment information, in this
sense, refers to any information that could have been specified by the deployment
descriptor or fragments, but instead is specified as annotations on classes.
If the value of the “metadata-complete” attribute is specified as true, the
deployment tool must ignore any annotations that specify such deployment
information in the class files packaged in the web application. Please see
Section 8.2.3, “Assembling the descriptor from web.xml, web-fragment.xml and
annotations” on page 8-82, Section 8.4, “Processing annotations and fragments” on
page 8-97 and Section 15.5.1, “Handling of metadata-complete” on page 15-194 for
additional details on the handling of “metadata-complete”.
If the “metadata-complete” attribute is not specified, or its value is false, the
deployment tool must examine the class files of the application for such annotations.
Note that a true value for “metadata-complete” does not preempt the
processing of all annotations, only those listed below.

Annotations that do not have equivalents in the deployment XSD include
javax.servlet.annotation.HandlesTypes and all of the CDI-related
annotations. These annotations must be processed during annotation scanning,
regardless of the value of “metadata-complete”.
When EJBs are packaged in a .war file, and the .war file contains an ejb-jar.xml
file, the metadata-complete attribute of the ejb-jar.xml file determines the
processing of the annotations for enterprise beans. If there is no ejb-jar.xml file,
and the web.xml specifies the metadata-complete attribute as “true”, these
annotations are processed as though there were an ejb-jar.xml file whose
metadata-complete attribute was specified as “true”. See the Enterprise
JavaBeans™ specification for requirements pertaining to annotations for EJBs.
The following are the annotations in javax.servlet. All of these have corresponding
deployment descriptor metadata covered by the Web xsd.
From javax.servlet.annotation:
■
■
■
■
■
■
■
■
HttpConstraint
HttpMethodConstraint
MultipartConfig
ServletSecurity
WebFilter
WebInitParam
WebListener
WebServlet
The following annotations from related packages are also covered by the web.xml
and associated fragments.
From javax.annotation:
■
■
■
■
PostConstruct
PreDestroy
Resource
Resources
From javax.annotation.security:
DeclareRoles
■ RunAs
■
From javax.annotation.sql:
DataSourceDefinition
■ DataSourceDefinitions
■
From javax.ejb:
■
■
EJB
EJBs
From javax.jms:
■
■
■
■
JMSConnectionFactoryDefinition
JMSConnectionFactoryDefinitions
JMSDestinationDefinition
JMSDestinationDefinitions
From javax.mail:
■
■
MailSessionDefinition
MailSessionDefinitions
From javax.persistence:
■
■
■
■
PersistenceContext
PersistenceContexts
PersistenceUnit
PersistenceUnits
From javax.resource:
■
■
■
■
AdministeredObjectDefinition
AdministeredObjectDefinitions
ConnectionFactoryDefinition
ConnectionFactoryDefinitions
All annotations in the following packages:
■javax.jws
■javax.jws.soap
■javax.xml.ws
■javax.xml.ws.soap
■javax.xml.ws.spi
Following are the annotations that MUST be supported by a Servlet compliant web
container.

Use the @WebServlet annotation to define a servlet component in a web application. This annotation is specified on a class and contains metadata about the servlet being declared. The annotated servlet must specify at least one URL pattern. This is done by using the urlPatterns or value attribute on the annotation. All other attributes are optional, with default settings. Use the value attribute when the only attribute on the annotation is the URL pattern; otherwise, use the urlPatterns attribute when other attributes are also used.

Classes annotated with @WebServlet must extend the jakarta.servlet.http.HttpServlet class.

```java
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;

@WebServlet("/")
public class ExampleServlet extends HttpServlet {
    ...
}
```

The web container initializes a servlet after loading and instantiating the servlet class and before delivering requests from clients. To customize this process to allow the servlet to read persistent configuration data, initialize resources, and perform any other one-time activities, you can either override the init method of the Servlet interface or specify the initParams attribute of the @WebServlet annotation. The initParams attribute contains a @WebInitParam annotation. If it cannot complete its initialization process, a servlet throws an UnavailableException.


* Annotation based configurations-Servlet Annotations are introduced in Servlet API 2.5 (JEE 5.0, JSE 5.0). These annotations are used to avoid writing the web.xml file.
@WebServlet annotation is used to declare a Servlet. This annotation is processed by the container at deployment time and the corresponding servlet made available at the specified URL patterns.

```java
@WebServlet
public class Servlet extends Httpservlet{
    .....
}
```

## Annotation Types

1. HandlesTypes -This annotation is used to declare the class types that a ServletContainerInitializer can handle.
2. HttpConstraint -This annotation is used within the ServletSecurity annotation to represent the security constraints to be applied to all HTTP protocol methods for which a corresponding HttpMethodConstraint element does NOT occur within the ServletSecurity annotation.
3. HttpMethodConstraint -This annotation is used within the ServletSecurity annotation to represent security constraints on specific HTTP protocol messages.
4. MultipartConfig -Annotation that may be specified on a Servlet class, indicating that instances of the Servlet expect requests that conform to the multipart/form-data MIME type.
5. ServletSecurity -This annotation is used on a Servlet implementation class to specify security constraints to be enforced by a Servlet container on HTTP protocol messages.
6. WebFilter -Annotation used to declare a servlet filter.
7. WebInitParam -This annotation is used on a Servlet or Filter implementation class to specify an initialization parameter.
8. WebListener -This annotation is used to declare a WebListener.
9. @WebServlet -Annotation used to declare a servlet.


## Dispatching Requests

When building a Web application, it is often useful to forward processing of a request to another servlet, or to include the output of another servlet in the response.
The RequestDispatcher interface provides a mechanism to accomplish this.

When asynchronous processing is enabled on the request, the AsyncContext allows a user to dispatch the request back to the servlet container.

- Obtaining a RequestDispatcher:- An object implementing the RequestDispatcher interface may be obtained from the
ServletContext via the following methods:

1. The getRequestDispatcher method takes a String argument describing a path within the scope of the ServletContext. This path must be relative to the root of the
ServletContext and begin with a ‘/’, or be empty. The method uses the path to look up a servlet, using the servlet path matching rules in Chapter 12, “Mapping
Requests to Servlets”, wraps it with a RequestDispatcher object, and returns the resulting object. If no servlet can be resolved based on the given path, a
RequestDispatcher is provided that returns the content for that path.
2. The getNamedDispatcher method takes a String argument indicating the name of a servlet known to the ServletContext. If a servlet is found, it is wrapped with a
RequestDispatcher object and the object is returned. If no servlet is associated with the given name, the method must return null.

### sessions and cookies

## The Servlet API

Servlets use classes and interfaces from two packages: javax.servlet
and javax.servlet.http. The javax.servlet package contains classes and interfaces to support generic, protocol-
independent servlets. These classes are extended by the classes in the javax.servlet.http package to add HTTP-specific
functionality. The top-level package name is javax instead of the familiar java, to indicate that the Servlet API is an Optional
Package (formerly called a Standard Extension).
Every servlet must implement the javax.servlet.Servlet interface. Most servlets implement this interface by extending one of
two special classes: javax.servlet.GenericServlet or javax.servlet.http.HttpServlet. A protocol-independent
servlet should subclass GenericServlet, while an HTTP servlet should subclass HttpServlet, which is itself a subclass of
GenericServlet with added HTTP-specific functionality.

Unlike a regular Java program, and just like an applet, a servlet does not have a main( ) method. Instead, certain methods of a
servlet are invoked by the server in the process of handling requests. Each time the server dispatches a request to a servlet, it
invokes the servlet's service( ) method.

A generic servlet should override its service( ) method to handle requests as appropriate for the servlet. The service( )
method accepts two parameters: a request object and a response object. The request object tells the servlet about the request,
while the response object is used to return a response.

In contrast, an HTTP servlet usually does not override the service( ) method. Instead, it overrides doGet( ) to handle GET
requests and doPost( ) to handle POST requests. An HTTP servlet can override either or both of these methods, depending on
the type of requests it needs to handle. The service( ) method of HttpServlet handles the setup and dispatching to all the
doXXX( ) methods, which is why it usually should not be overridden

An HTTP servlet can override the doPut( ) and doDelete( ) methods to handle PUT and DELETE requests, respectively.
However, HTTP servlets generally don't touch doTrace( ) or doOptions( ). For these, the default implementations are almost
always sufficient.
The remainder in the javax.servlet and javax.servlet.http packages are largely support classes. For example, the
ServletRequest and ServletResponse classes in javax.servlet provide access to generic server requests and responses,while HttpServletRequest and HttpServletResponse in javax.servlet.http provide access to HTTP requests and
responses. The javax.servlet.http package also contains an HttpSession interface that provides built-in session tracking
functionality and a Cookie class that allows you to quickly set up and process HTTP cookies.

## Page Generation

The most basic type of HTTP servlet generates a full HTML page. Such a servlet has access to the same information usually sent to
a CGI script, plus a bit more. A servlet that generates an HTML page can be used for all the tasks for which CGI is used currently,
such as for processing HTML forms, producing reports from a database, taking orders, checking identities, and so forth.

```java

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class HelloWorld extends HttpServlet {
public void doGet(HttpServletRequest req, HttpServletResponse res)
throws ServletException, IOException {
res.setContentType("text/html");
PrintWriter out = res.getWriter();
out.println("<HTML>");
out.println("<HEAD><TITLE>Hello World</TITLE></HEAD>");
out.println("<BODY>");
out.println("<BIG>Hello World</BIG>");
out.println("</BODY></HTML>");
}
}
```

This servlet extends the HttpServlet class and overrides the doGet( ) method inherited from it. Each time the web server
receives a GET request for this servlet, the server invokes this doGet( ) method, passing it an HttpServletRequest object and
an HttpServletResponse object.
The HttpServletRequest represents the client's request. This object gives a servlet access to information about the client, the
parameters for this request, the HTTP headers passed along with the request

The HttpServletResponse represents the servlet's response. A servlet can use this object to return data to the client. This data
can be of any content type, though the type should be specified as part of the response. A servlet can also use this object to set
HTTP response headers.

## Access Restriction to web Resource

Three types of authentication:-

1. `Basic authantication` causes the browser to display a dialog box that requests a username and a password.then,when the user enters a username and password,it sends this data as a plain text to the server so the server can attempt to authorize the user.since you don't have to code a form for this type of authentication,it is easy to implement.However,you can't control the appearance of this dialog box.

## Loading Servlets, Context Listeners, and Filters

Servlets, Context Listeners, and Filters are loaded and destroyed in the following
order:
Order of loading:

1. Context Listeners
2. Filters
3. Servlets
Order of destruction:

1. Servlets
2. Filters
3. Context Listeners

Servlets and filters are loaded in the same order they are defined in the web.xml file
and unloaded in reverse order. Context listeners are loaded in the following order:

1. All context listeners in the web.xml file in the order as specified in the file
2. Packaged JAR files containing tag library descriptors
3. Tag library descriptors in the WEB-INF directory

## Filters

Starting with servlet 2.3 specification, you can add a filter to your web application.
Filters are Java components that allow on the fly transformations of payload and header information in both the request into a resource and the response from a resource.

A filter is a reusable piece of code that can transform the content of HTTP requests,responses, and header information. Filters do not generally create a response or
respond to a request as servlets do, rather they modify or adapt the requests for a resource, and modify or adapt responses from a resource.
Filters can act on dynamic or static content.

A filter can intercept an HTTP request and execute code before or after the requested servlet or JSP is executed.As a result, filters are ideal for handling cross-cutting concerns,which are aspects of an application that cut across different parts of an application.

The Java Servlet API classes and methods that provide a lightweight framework for filtering active and static content. It describes how filters are configured in a Web
application, and conventions and semantics for their implementation.You can chain two or more filters together.

`Benefits of filters include`:-

1. *Modular code*.They allow you to create modular code that can be applied to different parts of an application.I.e the requested servlet doesn't need to hae any knowledge of the filter.As a result,you should be able to turn a filter on or off without affecting behavior of servlet.
2. *Flexible code*.They allow you to create flexible code.this works because you use an application's web.xml file to control when filters are executed.As aresult,you can easily apply filters to different parts of an application,and you can easily turn on or off. 

Filters are ideal for handling cross cutting concerns,e.g a filter can be used write data to a log file,handle authentication, or compress a response.In addition, a filter can be used to handle image type conversions,localizations,XSL transformations,caching.

If your servlet container already provides the type of functionality you need,it's usually easier and less error-prone to use the built-in functionality.As a result,before you code a custom filter to handle a complex task such as compressing responses,you should check the documentation for your servlet container to see if it already provides this type of functionality.

Examples of Filtering Components

- Authentication filters
- Logging and auditing filters
- Image conversion filters
- Data compression filters
- Encryption filters
- Tokenizing filters
- Filters that trigger resource access events
- XSL/T filters that transform XML content
- MIME-type chain filters
- Caching filters

`Adding a filter`.Adding a filter to an application works similarly to adding a servlet to an application.To start,you must code a class for the filter.Then,you add some code to the web.xml file to map the filter to one or more URL patterns.

A filter class must implement the **Filter** interface that includes the init,doFilter, and destroy methods that are called when the filter is initialized,executed, and destroyed.
The **init method** accepts a FilterConfig object as a parameter.You cam use this object's getFilterName method to get the name of the filter,and you can use its getServletContext method to get the servletContext object for the application.
The **doFilter** method accepts ServletRequest and ServletResponse objects as parameters.You can cast these objects to the HttpServletRequest and HttpServletResponse objects.
The doFilter method also accepts a FilterChain object.You can use the doFilter method of this object to forward the request and response to the next filter or servlet in the chain.